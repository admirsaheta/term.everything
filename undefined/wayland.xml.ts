/** This file has been generated by `task generate-protocol`  */
import { Sender } from "../Sender.ts";
import { Debug_Send_Message } from "../Send_Message.ts";
import { Object_ID, File_Descriptor, UInt32, Int32, Fixed, version } from "../wayland_types.ts";
import {DecodeState_Data} from "../Decode_State.ts";
import { Wayland_Client } from "../Wayland_Client.ts";
import {wayland_debug_time_only, show_wayland_surface_and_buffer} from "../debug.ts" with {type: "macro"};
import {Global_Ids} from "../GlobalObjects.ts";

export let debug_statement = 0;

export interface zwp_xwayland_keyboard_grab_manager_v1_delegate {
  /** @returns true if we should auto remove the object after destruction */
  zwp_xwayland_keyboard_grab_manager_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<zwp_xwayland_keyboard_grab_manager_v1>,
  ) => boolean;

  zwp_xwayland_keyboard_grab_manager_v1_grab_keyboard: (
    s: Wayland_Client,
    object_id: Object_ID<zwp_xwayland_keyboard_grab_manager_v1>,
    id: Object_ID<zwp_xwayland_keyboard_grab_v1>,
    surface: Object_ID<wl_surface>,
    seat: Object_ID<wl_seat>,
  ) => void;

  zwp_xwayland_keyboard_grab_manager_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<zwp_xwayland_keyboard_grab_manager_v1>,
    interface_: string,
    new_id: Object_ID<zwp_xwayland_keyboard_grab_manager_v1>,
    version_number: version,
  ) => void;
}

export class zwp_xwayland_keyboard_grab_manager_v1 {
  constructor(
    public delegate: zwp_xwayland_keyboard_grab_manager_v1_delegate,
  ) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zwp_xwayland_keyboard_grab_manager_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove =
          this.delegate.zwp_xwayland_keyboard_grab_manager_v1_destroy(
            s,
            message.object_id as any,
          );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zwp_xwayland_keyboard_grab_manager_v1@${message.object_id}.grab_keyboard(`,
            "id: ",
            id,
            ", ",
            "surface: ",
            surface,
            ", ",
            "seat: ",
            seat,
            ")",
          );
        }

        this.delegate.zwp_xwayland_keyboard_grab_manager_v1_grab_keyboard(
          s,
          message.object_id as any,
          id as any,
          surface as any,
          seat as any,
        );

        break;
      }

      default:
        console.error(
          "Unknown opcode on zwp_xwayland_keyboard_grab_manager_v1",
          message.opcode,
        );
        break;
    }
  };
}

export interface zwp_xwayland_keyboard_grab_v1_delegate {
  /** @returns true if we should auto remove the object after destruction */
  zwp_xwayland_keyboard_grab_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<zwp_xwayland_keyboard_grab_v1>,
  ) => boolean;

  zwp_xwayland_keyboard_grab_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<zwp_xwayland_keyboard_grab_v1>,
    interface_: string,
    new_id: Object_ID<zwp_xwayland_keyboard_grab_v1>,
    version_number: version,
  ) => void;
}

export class zwp_xwayland_keyboard_grab_v1 {
  constructor(public delegate: zwp_xwayland_keyboard_grab_v1_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zwp_xwayland_keyboard_grab_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.zwp_xwayland_keyboard_grab_v1_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      default:
        console.error(
          "Unknown opcode on zwp_xwayland_keyboard_grab_v1",
          message.opcode,
        );
        break;
    }
  };
}
export interface zxdg_decoration_manager_v1_delegate {
  /** @returns true if we should auto remove the object after destruction */
  zxdg_decoration_manager_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<zxdg_decoration_manager_v1>,
  ) => boolean;

  zxdg_decoration_manager_v1_get_toplevel_decoration: (
    s: Wayland_Client,
    object_id: Object_ID<zxdg_decoration_manager_v1>,
    id: Object_ID<zxdg_toplevel_decoration_v1>,
    toplevel: Object_ID<xdg_toplevel>,
  ) => void;

  zxdg_decoration_manager_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<zxdg_decoration_manager_v1>,
    interface_: string,
    new_id: Object_ID<zxdg_decoration_manager_v1>,
    version_number: version,
  ) => void;
}

export class zxdg_decoration_manager_v1 {
  constructor(public delegate: zxdg_decoration_manager_v1_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zxdg_decoration_manager_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.zxdg_decoration_manager_v1_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const toplevel =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zxdg_decoration_manager_v1@${message.object_id}.get_toplevel_decoration(`,
            "id: ",
            id,
            ", ",
            "toplevel: ",
            toplevel,
            ")",
          );
        }

        this.delegate.zxdg_decoration_manager_v1_get_toplevel_decoration(
          s,
          message.object_id as any,
          id as any,
          toplevel as any,
        );

        break;
      }

      default:
        console.error(
          "Unknown opcode on zxdg_decoration_manager_v1",
          message.opcode,
        );
        break;
    }
  };
}

export interface zxdg_toplevel_decoration_v1_delegate {
  /** @returns true if we should auto remove the object after destruction */
  zxdg_toplevel_decoration_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<zxdg_toplevel_decoration_v1>,
  ) => boolean;

  zxdg_toplevel_decoration_v1_set_mode: (
    s: Wayland_Client,
    object_id: Object_ID<zxdg_toplevel_decoration_v1>,
    mode: zxdg_toplevel_decoration_v1_mode,
  ) => void;

  zxdg_toplevel_decoration_v1_unset_mode: (
    s: Wayland_Client,
    object_id: Object_ID<zxdg_toplevel_decoration_v1>,
  ) => void;

  zxdg_toplevel_decoration_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<zxdg_toplevel_decoration_v1>,
    interface_: string,
    new_id: Object_ID<zxdg_toplevel_decoration_v1>,
    version_number: version,
  ) => void;
}

export class zxdg_toplevel_decoration_v1 {
  constructor(public delegate: zxdg_toplevel_decoration_v1_delegate) {}

  static configure = (
    s: Sender,
    event_object_id: Object_ID<zxdg_toplevel_decoration_v1>,
    mode: zxdg_toplevel_decoration_v1_mode,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      mode & 0xff,
      (mode >> 8) & 0xff,
      (mode >> 16) & 0xff,
      (mode >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "zxdg_toplevel_decoration_v1";
      d.message_name = "configure";
      d.message_args = [
        { signature: "mode: zxdg_toplevel_decoration_v1_mode", value: mode },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zxdg_toplevel_decoration_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.zxdg_toplevel_decoration_v1_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const mode =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zxdg_toplevel_decoration_v1@${message.object_id}.set_mode(`,
            "mode: ",
            mode,
            ")",
          );
        }

        this.delegate.zxdg_toplevel_decoration_v1_set_mode(
          s,
          message.object_id as any,
          mode as any,
        );

        break;
      }

      case 2: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} zxdg_toplevel_decoration_v1@${message.object_id}.unset_mode(`,
            ")",
          );
        }

        this.delegate.zxdg_toplevel_decoration_v1_unset_mode(
          s,
          message.object_id as any,
        );

        break;
      }

      default:
        console.error(
          "Unknown opcode on zxdg_toplevel_decoration_v1",
          message.opcode,
        );
        break;
    }
  };
}
export enum zxdg_toplevel_decoration_v1_error {
  unconfigured_buffer = 0,
  already_constructed = 1,
  orphaned = 2,
  invalid_mode = 3,
}
export enum zxdg_toplevel_decoration_v1_mode {
  client_side = 1,
  server_side = 2,
}
export interface xwayland_shell_v1_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xwayland_shell_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xwayland_shell_v1>,
  ) => boolean;

  xwayland_shell_v1_get_xwayland_surface: (
    s: Wayland_Client,
    object_id: Object_ID<xwayland_shell_v1>,
    id: Object_ID<xwayland_surface_v1>,
    surface: Object_ID<wl_surface>,
  ) => void;

  xwayland_shell_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xwayland_shell_v1>,
    interface_: string,
    new_id: Object_ID<xwayland_shell_v1>,
    version_number: version,
  ) => void;
}

export class xwayland_shell_v1 {
  constructor(public delegate: xwayland_shell_v1_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xwayland_shell_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xwayland_shell_v1_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xwayland_shell_v1@${message.object_id}.get_xwayland_surface(`,
            "id: ",
            id,
            ", ",
            "surface: ",
            surface,
            ")",
          );
        }

        this.delegate.xwayland_shell_v1_get_xwayland_surface(
          s,
          message.object_id as any,
          id as any,
          surface as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on xwayland_shell_v1", message.opcode);
        break;
    }
  };
}
export enum xwayland_shell_v1_error {
  role = 0,
}

export interface xwayland_surface_v1_delegate {
  xwayland_surface_v1_set_serial: (
    s: Wayland_Client,
    object_id: Object_ID<xwayland_surface_v1>,
    serial_lo: UInt32,
    serial_hi: UInt32,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  xwayland_surface_v1_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xwayland_surface_v1>,
  ) => boolean;

  xwayland_surface_v1_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xwayland_surface_v1>,
    interface_: string,
    new_id: Object_ID<xwayland_surface_v1>,
    version_number: version,
  ) => void;
}

export class xwayland_surface_v1 {
  constructor(public delegate: xwayland_surface_v1_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const serial_lo =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial_hi =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xwayland_surface_v1@${message.object_id}.set_serial(`,
            "serial_lo: ",
            serial_lo,
            ", ",
            "serial_hi: ",
            serial_hi,
            ")",
          );
        }

        this.delegate.xwayland_surface_v1_set_serial(
          s,
          message.object_id as any,
          serial_lo as any,
          serial_hi as any,
        );

        break;
      }

      case 1: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xwayland_surface_v1@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xwayland_surface_v1_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on xwayland_surface_v1", message.opcode);
        break;
    }
  };
}
export enum xwayland_surface_v1_error {
  already_associated = 0,
  invalid_serial = 1,
}
export interface xdg_wm_base_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xdg_wm_base_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_wm_base>,
  ) => boolean;

  xdg_wm_base_create_positioner: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_wm_base>,
    id: Object_ID<xdg_positioner>,
  ) => void;

  xdg_wm_base_get_xdg_surface: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_wm_base>,
    id: Object_ID<xdg_surface>,
    surface: Object_ID<wl_surface>,
  ) => void;

  xdg_wm_base_pong: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_wm_base>,
    serial: UInt32,
  ) => void;

  xdg_wm_base_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xdg_wm_base>,
    interface_: string,
    new_id: Object_ID<xdg_wm_base>,
    version_number: version,
  ) => void;
}

export class xdg_wm_base {
  constructor(public delegate: xdg_wm_base_delegate) {}

  static ping = (
    s: Sender,
    event_object_id: Object_ID<xdg_wm_base>,
    serial: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_wm_base";
      d.message_name = "ping";
      d.message_args = [{ signature: "serial: UInt32", value: serial }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_wm_base@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xdg_wm_base_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_wm_base@${message.object_id}.create_positioner(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.xdg_wm_base_create_positioner(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 2: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_wm_base@${message.object_id}.get_xdg_surface(`,
            "id: ",
            id,
            ", ",
            "surface: ",
            surface,
            ")",
          );
        }

        this.delegate.xdg_wm_base_get_xdg_surface(
          s,
          message.object_id as any,
          id as any,
          surface as any,
        );

        break;
      }

      case 3: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_wm_base@${message.object_id}.pong(`,
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.xdg_wm_base_pong(
          s,
          message.object_id as any,
          serial as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on xdg_wm_base", message.opcode);
        break;
    }
  };
}
export enum xdg_wm_base_error {
  role = 0,
  defunct_surfaces = 1,
  not_the_topmost_popup = 2,
  invalid_popup_parent = 3,
  invalid_surface_state = 4,
  invalid_positioner = 5,
  unresponsive = 6,
}

export interface xdg_positioner_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xdg_positioner_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
  ) => boolean;

  xdg_positioner_set_size: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    width: Int32,
    height: Int32,
  ) => void;

  xdg_positioner_set_anchor_rect: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  xdg_positioner_set_anchor: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    anchor: xdg_positioner_anchor,
  ) => void;

  xdg_positioner_set_gravity: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    gravity: xdg_positioner_gravity,
  ) => void;

  xdg_positioner_set_constraint_adjustment: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    constraint_adjustment: xdg_positioner_constraint_adjustment,
  ) => void;

  xdg_positioner_set_offset: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    x: Int32,
    y: Int32,
  ) => void;

  xdg_positioner_set_reactive: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
  ) => void;

  xdg_positioner_set_parent_size: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    parent_width: Int32,
    parent_height: Int32,
  ) => void;

  xdg_positioner_set_parent_configure: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_positioner>,
    serial: UInt32,
  ) => void;

  xdg_positioner_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xdg_positioner>,
    interface_: string,
    new_id: Object_ID<xdg_positioner>,
    version_number: version,
  ) => void;
}

export class xdg_positioner {
  constructor(public delegate: xdg_positioner_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xdg_positioner_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_size(`,
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_size(
          s,
          message.object_id as any,
          width as any,
          height as any,
        );

        break;
      }

      case 2: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_anchor_rect(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_anchor_rect(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      case 3: {
        const anchor =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_anchor(`,
            "anchor: ",
            anchor,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_anchor(
          s,
          message.object_id as any,
          anchor as any,
        );

        break;
      }

      case 4: {
        const gravity =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_gravity(`,
            "gravity: ",
            gravity,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_gravity(
          s,
          message.object_id as any,
          gravity as any,
        );

        break;
      }

      case 5: {
        const constraint_adjustment =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_constraint_adjustment(`,
            "constraint_adjustment: ",
            constraint_adjustment,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_constraint_adjustment(
          s,
          message.object_id as any,
          constraint_adjustment as any,
        );

        break;
      }

      case 6: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_offset(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_offset(
          s,
          message.object_id as any,
          x as any,
          y as any,
        );

        break;
      }

      case 7: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_reactive(`,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_reactive(s, message.object_id as any);

        break;
      }

      case 8: {
        const parent_width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const parent_height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_parent_size(`,
            "parent_width: ",
            parent_width,
            ", ",
            "parent_height: ",
            parent_height,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_parent_size(
          s,
          message.object_id as any,
          parent_width as any,
          parent_height as any,
        );

        break;
      }

      case 9: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_positioner@${message.object_id}.set_parent_configure(`,
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.xdg_positioner_set_parent_configure(
          s,
          message.object_id as any,
          serial as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on xdg_positioner", message.opcode);
        break;
    }
  };
}
export enum xdg_positioner_error {
  invalid_input = 0,
}
export enum xdg_positioner_anchor {
  none = 0,
  top = 1,
  bottom = 2,
  left = 3,
  right = 4,
  top_left = 5,
  bottom_left = 6,
  top_right = 7,
  bottom_right = 8,
}
export enum xdg_positioner_gravity {
  none = 0,
  top = 1,
  bottom = 2,
  left = 3,
  right = 4,
  top_left = 5,
  bottom_left = 6,
  top_right = 7,
  bottom_right = 8,
}
export enum xdg_positioner_constraint_adjustment {
  none = 0,
  slide_x = 1,
  slide_y = 2,
  flip_x = 4,
  flip_y = 8,
  resize_x = 16,
  resize_y = 32,
}

export interface xdg_surface_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xdg_surface_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_surface>,
  ) => boolean;

  xdg_surface_get_toplevel: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_surface>,
    id: Object_ID<xdg_toplevel>,
  ) => void;

  xdg_surface_get_popup: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_surface>,
    id: Object_ID<xdg_popup>,
    parent: Object_ID<xdg_surface> | null,
    positioner: Object_ID<xdg_positioner>,
  ) => void;

  xdg_surface_set_window_geometry: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_surface>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  xdg_surface_ack_configure: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_surface>,
    serial: UInt32,
  ) => void;

  xdg_surface_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xdg_surface>,
    interface_: string,
    new_id: Object_ID<xdg_surface>,
    version_number: version,
  ) => void;
}

export class xdg_surface {
  constructor(public delegate: xdg_surface_delegate) {}

  static configure = (
    s: Sender,
    event_object_id: Object_ID<xdg_surface>,
    serial: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_surface";
      d.message_name = "configure";
      d.message_args = [{ signature: "serial: UInt32", value: serial }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_surface@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xdg_surface_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_surface@${message.object_id}.get_toplevel(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.xdg_surface_get_toplevel(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 2: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const __temp_parent =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const parent = __temp_parent === 0 ? null : __temp_parent;

        const positioner =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_surface@${message.object_id}.get_popup(`,
            "id: ",
            id,
            ", ",
            "parent: ",
            parent,
            ", ",
            "positioner: ",
            positioner,
            ")",
          );
        }

        this.delegate.xdg_surface_get_popup(
          s,
          message.object_id as any,
          id as any,
          parent as any,
          positioner as any,
        );

        break;
      }

      case 3: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_surface@${message.object_id}.set_window_geometry(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.xdg_surface_set_window_geometry(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      case 4: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_surface@${message.object_id}.ack_configure(`,
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.xdg_surface_ack_configure(
          s,
          message.object_id as any,
          serial as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on xdg_surface", message.opcode);
        break;
    }
  };
}
export enum xdg_surface_error {
  not_constructed = 1,
  already_constructed = 2,
  unconfigured_buffer = 3,
  invalid_serial = 4,
  invalid_size = 5,
  defunct_role_object = 6,
}

export interface xdg_toplevel_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xdg_toplevel_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
  ) => boolean;

  xdg_toplevel_set_parent: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    parent: Object_ID<xdg_toplevel> | null,
  ) => void;

  xdg_toplevel_set_title: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    title: string,
  ) => void;

  xdg_toplevel_set_app_id: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    app_id: string,
  ) => void;

  xdg_toplevel_show_window_menu: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
    x: Int32,
    y: Int32,
  ) => void;

  xdg_toplevel_move: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
  ) => void;

  xdg_toplevel_resize: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
    edges: xdg_toplevel_resize_edge,
  ) => void;

  xdg_toplevel_set_max_size: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    width: Int32,
    height: Int32,
  ) => void;

  xdg_toplevel_set_min_size: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    width: Int32,
    height: Int32,
  ) => void;

  xdg_toplevel_set_maximized: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
  ) => void;

  xdg_toplevel_unset_maximized: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
  ) => void;

  xdg_toplevel_set_fullscreen: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
    output: Object_ID<wl_output> | null,
  ) => void;

  xdg_toplevel_unset_fullscreen: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
  ) => void;

  xdg_toplevel_set_minimized: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_toplevel>,
  ) => void;

  xdg_toplevel_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xdg_toplevel>,
    interface_: string,
    new_id: Object_ID<xdg_toplevel>,
    version_number: version,
  ) => void;
}

export class xdg_toplevel {
  constructor(public delegate: xdg_toplevel_delegate) {}

  static configure = (
    s: Sender,
    event_object_id: Object_ID<xdg_toplevel>,
    width: Int32,
    height: Int32,
    states: number[],
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      width & 0xff,
      (width >> 8) & 0xff,
      (width >> 16) & 0xff,
      (width >> 24) & 0xff,
    );
    data.push(
      height & 0xff,
      (height >> 8) & 0xff,
      (height >> 16) & 0xff,
      (height >> 24) & 0xff,
    );

    data.push(
      states.length & 0xff,
      (states.length >> 8) & 0xff,
      (states.length >> 16) & 0xff,
      (states.length >> 24) & 0xff,
    );
    data.push(...states);
    if (states.length % 4 !== 0) {
      const padding = 4 - (states.length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_toplevel";
      d.message_name = "configure";
      d.message_args = [
        { signature: "width: Int32", value: width },
        { signature: "height: Int32", value: height },
        { signature: "states: number[]", value: states },
      ];
    }
    s.send(object);
  };

  static close = (s: Sender, event_object_id: Object_ID<xdg_toplevel>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_toplevel";
      d.message_name = "close";
      d.message_args = [];
    }
    s.send(object);
  };

  static configure_bounds = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<xdg_toplevel>,
    width: Int32,
    height: Int32,
  ) => {
    if (bound_version < 4) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event configure_bounds is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      width & 0xff,
      (width >> 8) & 0xff,
      (width >> 16) & 0xff,
      (width >> 24) & 0xff,
    );
    data.push(
      height & 0xff,
      (height >> 8) & 0xff,
      (height >> 16) & 0xff,
      (height >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_toplevel";
      d.message_name = "configure_bounds";
      d.message_args = [
        { signature: "width: Int32", value: width },
        { signature: "height: Int32", value: height },
      ];
    }
    s.send(object);
  };

  static wm_capabilities = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<xdg_toplevel>,
    capabilities: number[],
  ) => {
    if (bound_version < 5) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event wm_capabilities is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    data.push(
      capabilities.length & 0xff,
      (capabilities.length >> 8) & 0xff,
      (capabilities.length >> 16) & 0xff,
      (capabilities.length >> 24) & 0xff,
    );
    data.push(...capabilities);
    if (capabilities.length % 4 !== 0) {
      const padding = 4 - (capabilities.length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_toplevel";
      d.message_name = "wm_capabilities";
      d.message_args = [
        { signature: "capabilities: number[]", value: capabilities },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xdg_toplevel_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const __temp_parent =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const parent = __temp_parent === 0 ? null : __temp_parent;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_parent(`,
            "parent: ",
            parent,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_parent(
          s,
          message.object_id as any,
          parent as any,
        );

        break;
      }

      case 2: {
        const title_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const title = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + title_length - 1,
            ),
          ),
        );
        if (title_length % 4 !== 0) {
          _data_in_offset__ += title_length + (4 - (title_length % 4));
        } else {
          _data_in_offset__ += title_length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_title(`,
            "title: ",
            title,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_title(
          s,
          message.object_id as any,
          title as any,
        );

        break;
      }

      case 3: {
        const app_id_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const app_id = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + app_id_length - 1,
            ),
          ),
        );
        if (app_id_length % 4 !== 0) {
          _data_in_offset__ += app_id_length + (4 - (app_id_length % 4));
        } else {
          _data_in_offset__ += app_id_length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_app_id(`,
            "app_id: ",
            app_id,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_app_id(
          s,
          message.object_id as any,
          app_id as any,
        );

        break;
      }

      case 4: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.show_window_menu(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ", ",
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ")",
          );
        }

        this.delegate.xdg_toplevel_show_window_menu(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
          x as any,
          y as any,
        );

        break;
      }

      case 5: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.move(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.xdg_toplevel_move(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
        );

        break;
      }

      case 6: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const edges =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.resize(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ", ",
            "edges: ",
            edges,
            ")",
          );
        }

        this.delegate.xdg_toplevel_resize(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
          edges as any,
        );

        break;
      }

      case 7: {
        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_max_size(`,
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_max_size(
          s,
          message.object_id as any,
          width as any,
          height as any,
        );

        break;
      }

      case 8: {
        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_min_size(`,
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_min_size(
          s,
          message.object_id as any,
          width as any,
          height as any,
        );

        break;
      }

      case 9: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_maximized(`,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_maximized(s, message.object_id as any);

        break;
      }

      case 10: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.unset_maximized(`,
            ")",
          );
        }

        this.delegate.xdg_toplevel_unset_maximized(s, message.object_id as any);

        break;
      }

      case 11: {
        const __temp_output =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const output = __temp_output === 0 ? null : __temp_output;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_fullscreen(`,
            "output: ",
            output,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_fullscreen(
          s,
          message.object_id as any,
          output as any,
        );

        break;
      }

      case 12: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.unset_fullscreen(`,
            ")",
          );
        }

        this.delegate.xdg_toplevel_unset_fullscreen(
          s,
          message.object_id as any,
        );

        break;
      }

      case 13: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_toplevel@${message.object_id}.set_minimized(`,
            ")",
          );
        }

        this.delegate.xdg_toplevel_set_minimized(s, message.object_id as any);

        break;
      }

      default:
        console.error("Unknown opcode on xdg_toplevel", message.opcode);
        break;
    }
  };
}
export enum xdg_toplevel_error {
  invalid_resize_edge = 0,
  invalid_parent = 1,
  invalid_size = 2,
}
export enum xdg_toplevel_resize_edge {
  none = 0,
  top = 1,
  bottom = 2,
  left = 4,
  top_left = 5,
  bottom_left = 6,
  right = 8,
  top_right = 9,
  bottom_right = 10,
}
export enum xdg_toplevel_state {
  maximized = 1,
  fullscreen = 2,
  resizing = 3,
  activated = 4,
  tiled_left = 5,
  tiled_right = 6,
  tiled_top = 7,
  tiled_bottom = 8,
  suspended = 9,
}
export enum xdg_toplevel_wm_capabilities {
  window_menu = 1,
  maximize = 2,
  fullscreen = 3,
  minimize = 4,
}

export interface xdg_popup_delegate {
  /** @returns true if we should auto remove the object after destruction */
  xdg_popup_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_popup>,
  ) => boolean;

  xdg_popup_grab: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_popup>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
  ) => void;

  xdg_popup_reposition: (
    s: Wayland_Client,
    object_id: Object_ID<xdg_popup>,
    positioner: Object_ID<xdg_positioner>,
    token: UInt32,
  ) => void;

  xdg_popup_on_bind: (
    s: Wayland_Client,
    name: Object_ID<xdg_popup>,
    interface_: string,
    new_id: Object_ID<xdg_popup>,
    version_number: version,
  ) => void;
}

export class xdg_popup {
  constructor(public delegate: xdg_popup_delegate) {}

  static configure = (
    s: Sender,
    event_object_id: Object_ID<xdg_popup>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(x & 0xff, (x >> 8) & 0xff, (x >> 16) & 0xff, (x >> 24) & 0xff);
    data.push(y & 0xff, (y >> 8) & 0xff, (y >> 16) & 0xff, (y >> 24) & 0xff);
    data.push(
      width & 0xff,
      (width >> 8) & 0xff,
      (width >> 16) & 0xff,
      (width >> 24) & 0xff,
    );
    data.push(
      height & 0xff,
      (height >> 8) & 0xff,
      (height >> 16) & 0xff,
      (height >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_popup";
      d.message_name = "configure";
      d.message_args = [
        { signature: "x: Int32", value: x },
        { signature: "y: Int32", value: y },
        { signature: "width: Int32", value: width },
        { signature: "height: Int32", value: height },
      ];
    }
    s.send(object);
  };

  static popup_done = (s: Sender, event_object_id: Object_ID<xdg_popup>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_popup";
      d.message_name = "popup_done";
      d.message_args = [];
    }
    s.send(object);
  };

  static repositioned = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<xdg_popup>,
    token: UInt32,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event repositioned is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      token & 0xff,
      (token >> 8) & 0xff,
      (token >> 16) & 0xff,
      (token >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "xdg_popup";
      d.message_name = "repositioned";
      d.message_args = [{ signature: "token: UInt32", value: token }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_popup@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.xdg_popup_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_popup@${message.object_id}.grab(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.xdg_popup_grab(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
        );

        break;
      }

      case 2: {
        const positioner =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const token =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} xdg_popup@${message.object_id}.reposition(`,
            "positioner: ",
            positioner,
            ", ",
            "token: ",
            token,
            ")",
          );
        }

        this.delegate.xdg_popup_reposition(
          s,
          message.object_id as any,
          positioner as any,
          token as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on xdg_popup", message.opcode);
        break;
    }
  };
}
export enum xdg_popup_error {
  invalid_grab = 0,
}
export interface wl_display_delegate {
  wl_display_sync: (
    s: Wayland_Client,
    object_id: Object_ID<wl_display>,
    callback: Object_ID<wl_callback>,
  ) => void;

  wl_display_get_registry: (
    s: Wayland_Client,
    object_id: Object_ID<wl_display>,
    registry: Object_ID<wl_registry>,
  ) => void;

  wl_display_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_display>,
    interface_: string,
    new_id: Object_ID<wl_display>,
    version_number: version,
  ) => void;
}

export class wl_display {
  constructor(public delegate: wl_display_delegate) {}

  static error = (
    s: Sender,
    event_object_id: Object_ID<wl_display>,
    object_id: Object_ID,
    code: UInt32,
    message: string,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      object_id & 0xff,
      (object_id >> 8) & 0xff,
      (object_id >> 16) & 0xff,
      (object_id >> 24) & 0xff,
    );
    data.push(
      code & 0xff,
      (code >> 8) & 0xff,
      (code >> 16) & 0xff,
      (code >> 24) & 0xff,
    );

    const message_utf8 = new TextEncoder().encode(message);
    const message_total_length = message_utf8.length + 1;
    data.push(
      message_total_length & 0xff,
      (message_total_length >> 8) & 0xff,
      (message_total_length >> 16) & 0xff,
      (message_total_length >> 24) & 0xff,
    );
    data.push(...message_utf8);
    data.push(0); /* Null terminator */
    if (message_total_length % 4 !== 0) {
      const padding = 4 - (message_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_display";
      d.message_name = "error";
      d.message_args = [
        { signature: "object_id: Object_ID   ", value: object_id },
        { signature: "code: UInt32", value: code },
        { signature: "message: string", value: message },
      ];
    }
    s.send(object);
  };

  static delete_id = (
    s: Sender,
    event_object_id: Object_ID<wl_display>,
    id: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_display";
      d.message_name = "delete_id";
      d.message_args = [{ signature: "id: UInt32", value: id }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const callback =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_display@${message.object_id}.sync(`,
            "callback: ",
            callback,
            ")",
          );
        }

        this.delegate.wl_display_sync(
          s,
          message.object_id as any,
          callback as any,
        );

        break;
      }

      case 1: {
        const registry =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_display@${message.object_id}.get_registry(`,
            "registry: ",
            registry,
            ")",
          );
        }

        this.delegate.wl_display_get_registry(
          s,
          message.object_id as any,
          registry as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_display", message.opcode);
        break;
    }
  };
}
export enum wl_display_error {
  invalid_object = 0,
  invalid_method = 1,
  no_memory = 2,
  implementation = 3,
}

export interface wl_registry_delegate {
  wl_registry_bind: (
    s: Wayland_Client,
    object_id: Object_ID<wl_registry>,
    name: UInt32,
    id_interface: string,
    id_version: UInt32,
    id_id: Object_ID,
  ) => void;

  wl_registry_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_registry>,
    interface_: string,
    new_id: Object_ID<wl_registry>,
    version_number: version,
  ) => void;
}

export class wl_registry {
  constructor(public delegate: wl_registry_delegate) {}

  static global = (
    s: Sender,
    event_object_id: Object_ID<wl_registry>,
    name: UInt32,
    interface_: string,
    version: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      name & 0xff,
      (name >> 8) & 0xff,
      (name >> 16) & 0xff,
      (name >> 24) & 0xff,
    );

    const interface__utf8 = new TextEncoder().encode(interface_);
    const interface__total_length = interface__utf8.length + 1;
    data.push(
      interface__total_length & 0xff,
      (interface__total_length >> 8) & 0xff,
      (interface__total_length >> 16) & 0xff,
      (interface__total_length >> 24) & 0xff,
    );
    data.push(...interface__utf8);
    data.push(0); /* Null terminator */
    if (interface__total_length % 4 !== 0) {
      const padding = 4 - (interface__total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    data.push(
      version & 0xff,
      (version >> 8) & 0xff,
      (version >> 16) & 0xff,
      (version >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_registry";
      d.message_name = "global";
      d.message_args = [
        { signature: "name: UInt32", value: name },
        { signature: "interface_: string", value: interface_ },
        { signature: "version: UInt32", value: version },
      ];
    }
    s.send(object);
  };

  static global_remove = (
    s: Sender,
    event_object_id: Object_ID<wl_registry>,
    name: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      name & 0xff,
      (name >> 8) & 0xff,
      (name >> 16) & 0xff,
      (name >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_registry";
      d.message_name = "global_remove";
      d.message_args = [{ signature: "name: UInt32", value: name }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const name =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const id_interface_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const id_interface = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + id_interface_length - 1,
            ),
          ),
        );
        if (id_interface_length % 4 !== 0) {
          _data_in_offset__ +=
            id_interface_length + (4 - (id_interface_length % 4));
        } else {
          _data_in_offset__ += id_interface_length;
        }

        const id_version =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const id_id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_registry@${message.object_id}.bind(`,
            "name: ",
            name,
            ", ",
            "id_interface: ",
            id_interface,
            ", ",
            "id_version: ",
            id_version,
            ", ",
            "id_id: ",
            id_id,
            ")",
          );
        }

        this.delegate.wl_registry_bind(
          s,
          message.object_id as any,
          name as any,
          id_interface as any,
          id_version as any,
          id_id as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_registry", message.opcode);
        break;
    }
  };
}

export interface wl_callback_delegate {}

export class wl_callback {
  constructor(public delegate: wl_callback_delegate) {}

  static done = (
    s: Sender,
    event_object_id: Object_ID<wl_callback>,
    callback_data: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      callback_data & 0xff,
      (callback_data >> 8) & 0xff,
      (callback_data >> 16) & 0xff,
      (callback_data >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_callback";
      d.message_name = "done";
      d.message_args = [
        { signature: "callback_data: UInt32", value: callback_data },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      default:
        console.error("Unknown opcode on wl_callback", message.opcode);
        break;
    }
  };
}

export interface wl_compositor_delegate {
  wl_compositor_create_surface: (
    s: Wayland_Client,
    object_id: Object_ID<wl_compositor>,
    id: Object_ID<wl_surface>,
  ) => void;

  wl_compositor_create_region: (
    s: Wayland_Client,
    object_id: Object_ID<wl_compositor>,
    id: Object_ID<wl_region>,
  ) => void;

  wl_compositor_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_compositor>,
    interface_: string,
    new_id: Object_ID<wl_compositor>,
    version_number: version,
  ) => void;
}

export class wl_compositor {
  constructor(public delegate: wl_compositor_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_compositor@${message.object_id}.create_surface(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_compositor_create_surface(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_compositor@${message.object_id}.create_region(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_compositor_create_region(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_compositor", message.opcode);
        break;
    }
  };
}

export interface wl_shm_pool_delegate {
  wl_shm_pool_create_buffer: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shm_pool>,
    id: Object_ID<wl_buffer>,
    offset: Int32,
    width: Int32,
    height: Int32,
    stride: Int32,
    format: wl_shm_format,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_shm_pool_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shm_pool>,
  ) => boolean;

  wl_shm_pool_resize: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shm_pool>,
    size: Int32,
  ) => void;

  wl_shm_pool_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_shm_pool>,
    interface_: string,
    new_id: Object_ID<wl_shm_pool>,
    version_number: version,
  ) => void;
}

export class wl_shm_pool {
  constructor(public delegate: wl_shm_pool_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const offset =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const stride =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const format =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shm_pool@${message.object_id}.create_buffer(`,
            "id: ",
            id,
            ", ",
            "offset: ",
            offset,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ", ",
            "stride: ",
            stride,
            ", ",
            "format: ",
            format,
            ")",
          );
        }

        this.delegate.wl_shm_pool_create_buffer(
          s,
          message.object_id as any,
          id as any,
          offset as any,
          width as any,
          height as any,
          stride as any,
          format as any,
        );

        break;
      }

      case 1: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shm_pool@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_shm_pool_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 2: {
        const size =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shm_pool@${message.object_id}.resize(`,
            "size: ",
            size,
            ")",
          );
        }

        this.delegate.wl_shm_pool_resize(
          s,
          message.object_id as any,
          size as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_shm_pool", message.opcode);
        break;
    }
  };
}

export interface wl_shm_delegate {
  wl_shm_create_pool: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shm>,
    id: Object_ID<wl_shm_pool>,
    fd: File_Descriptor,
    size: Int32,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_shm_release: (s: Wayland_Client, object_id: Object_ID<wl_shm>) => boolean;

  wl_shm_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_shm>,
    interface_: string,
    new_id: Object_ID<wl_shm>,
    version_number: version,
  ) => void;
}

export class wl_shm {
  constructor(public delegate: wl_shm_delegate) {}

  static format = (
    s: Sender,
    event_object_id: Object_ID<wl_shm>,
    format: wl_shm_format,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      format & 0xff,
      (format >> 8) & 0xff,
      (format >> 16) & 0xff,
      (format >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_shm";
      d.message_name = "format";
      d.message_args = [{ signature: "format: wl_shm_format", value: format }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const fd = s.claim_file_descriptor();

        const size =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shm@${message.object_id}.create_pool(`,
            "id: ",
            id,
            ", ",
            "fd: ",
            fd,
            ", ",
            "size: ",
            size,
            ")",
          );
        }

        this.delegate.wl_shm_create_pool(
          s,
          message.object_id as any,
          id as any,
          fd as any,
          size as any,
        );

        break;
      }

      case 1: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shm@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_shm_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(Global_Ids.wl_shm, message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_shm", message.opcode);
        break;
    }
  };
}
export enum wl_shm_error {
  invalid_format = 0,
  invalid_stride = 1,
  invalid_fd = 2,
}
export enum wl_shm_format {
  argb8888 = 0,
  xrgb8888 = 1,
  c8 = 0x20203843,
  rgb332 = 0x38424752,
  bgr233 = 0x38524742,
  xrgb4444 = 0x32315258,
  xbgr4444 = 0x32314258,
  rgbx4444 = 0x32315852,
  bgrx4444 = 0x32315842,
  argb4444 = 0x32315241,
  abgr4444 = 0x32314241,
  rgba4444 = 0x32314152,
  bgra4444 = 0x32314142,
  xrgb1555 = 0x35315258,
  xbgr1555 = 0x35314258,
  rgbx5551 = 0x35315852,
  bgrx5551 = 0x35315842,
  argb1555 = 0x35315241,
  abgr1555 = 0x35314241,
  rgba5551 = 0x35314152,
  bgra5551 = 0x35314142,
  rgb565 = 0x36314752,
  bgr565 = 0x36314742,
  rgb888 = 0x34324752,
  bgr888 = 0x34324742,
  xbgr8888 = 0x34324258,
  rgbx8888 = 0x34325852,
  bgrx8888 = 0x34325842,
  abgr8888 = 0x34324241,
  rgba8888 = 0x34324152,
  bgra8888 = 0x34324142,
  xrgb2101010 = 0x30335258,
  xbgr2101010 = 0x30334258,
  rgbx1010102 = 0x30335852,
  bgrx1010102 = 0x30335842,
  argb2101010 = 0x30335241,
  abgr2101010 = 0x30334241,
  rgba1010102 = 0x30334152,
  bgra1010102 = 0x30334142,
  yuyv = 0x56595559,
  yvyu = 0x55595659,
  uyvy = 0x59565955,
  vyuy = 0x59555956,
  ayuv = 0x56555941,
  nv12 = 0x3231564e,
  nv21 = 0x3132564e,
  nv16 = 0x3631564e,
  nv61 = 0x3136564e,
  yuv410 = 0x39565559,
  yvu410 = 0x39555659,
  yuv411 = 0x31315559,
  yvu411 = 0x31315659,
  yuv420 = 0x32315559,
  yvu420 = 0x32315659,
  yuv422 = 0x36315559,
  yvu422 = 0x36315659,
  yuv444 = 0x34325559,
  yvu444 = 0x34325659,
  r8 = 0x20203852,
  r16 = 0x20363152,
  rg88 = 0x38384752,
  gr88 = 0x38385247,
  rg1616 = 0x32334752,
  gr1616 = 0x32335247,
  xrgb16161616f = 0x48345258,
  xbgr16161616f = 0x48344258,
  argb16161616f = 0x48345241,
  abgr16161616f = 0x48344241,
  xyuv8888 = 0x56555958,
  vuy888 = 0x34325556,
  vuy101010 = 0x30335556,
  y210 = 0x30313259,
  y212 = 0x32313259,
  y216 = 0x36313259,
  y410 = 0x30313459,
  y412 = 0x32313459,
  y416 = 0x36313459,
  xvyu2101010 = 0x30335658,
  xvyu12_16161616 = 0x36335658,
  xvyu16161616 = 0x38345658,
  y0l0 = 0x304c3059,
  x0l0 = 0x304c3058,
  y0l2 = 0x324c3059,
  x0l2 = 0x324c3058,
  yuv420_8bit = 0x38305559,
  yuv420_10bit = 0x30315559,
  xrgb8888_a8 = 0x38415258,
  xbgr8888_a8 = 0x38414258,
  rgbx8888_a8 = 0x38415852,
  bgrx8888_a8 = 0x38415842,
  rgb888_a8 = 0x38413852,
  bgr888_a8 = 0x38413842,
  rgb565_a8 = 0x38413552,
  bgr565_a8 = 0x38413542,
  nv24 = 0x3432564e,
  nv42 = 0x3234564e,
  p210 = 0x30313250,
  p010 = 0x30313050,
  p012 = 0x32313050,
  p016 = 0x36313050,
  axbxgxrx106106106106 = 0x30314241,
  nv15 = 0x3531564e,
  q410 = 0x30313451,
  q401 = 0x31303451,
  xrgb16161616 = 0x38345258,
  xbgr16161616 = 0x38344258,
  argb16161616 = 0x38345241,
  abgr16161616 = 0x38344241,
  c1 = 0x20203143,
  c2 = 0x20203243,
  c4 = 0x20203443,
  d1 = 0x20203144,
  d2 = 0x20203244,
  d4 = 0x20203444,
  d8 = 0x20203844,
  r1 = 0x20203152,
  r2 = 0x20203252,
  r4 = 0x20203452,
  r10 = 0x20303152,
  r12 = 0x20323152,
  avuy8888 = 0x59555641,
  xvuy8888 = 0x59555658,
  p030 = 0x30333050,
}

export interface wl_buffer_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_buffer_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_buffer>,
  ) => boolean;

  wl_buffer_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_buffer>,
    interface_: string,
    new_id: Object_ID<wl_buffer>,
    version_number: version,
  ) => void;
}

export class wl_buffer {
  constructor(public delegate: wl_buffer_delegate) {}

  static release = (s: Sender, event_object_id: Object_ID<wl_buffer>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_buffer";
      d.message_name = "release";
      d.message_args = [];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_buffer@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_buffer_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_buffer", message.opcode);
        break;
    }
  };
}

export interface wl_data_offer_delegate {
  wl_data_offer_accept: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_offer>,
    serial: UInt32,
    mime_type: string,
  ) => void;

  wl_data_offer_receive: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_offer>,
    mime_type: string,
    fd: File_Descriptor,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_data_offer_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_offer>,
  ) => boolean;

  wl_data_offer_finish: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_offer>,
  ) => void;

  wl_data_offer_set_actions: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_offer>,
    dnd_actions: wl_data_device_manager_dnd_action,
    preferred_action: wl_data_device_manager_dnd_action,
  ) => void;

  wl_data_offer_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_data_offer>,
    interface_: string,
    new_id: Object_ID<wl_data_offer>,
    version_number: version,
  ) => void;
}

export class wl_data_offer {
  constructor(public delegate: wl_data_offer_delegate) {}

  static offer = (
    s: Sender,
    event_object_id: Object_ID<wl_data_offer>,
    mime_type: string,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const mime_type_utf8 = new TextEncoder().encode(mime_type);
    const mime_type_total_length = mime_type_utf8.length + 1;
    data.push(
      mime_type_total_length & 0xff,
      (mime_type_total_length >> 8) & 0xff,
      (mime_type_total_length >> 16) & 0xff,
      (mime_type_total_length >> 24) & 0xff,
    );
    data.push(...mime_type_utf8);
    data.push(0); /* Null terminator */
    if (mime_type_total_length % 4 !== 0) {
      const padding = 4 - (mime_type_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_offer";
      d.message_name = "offer";
      d.message_args = [{ signature: "mime_type: string", value: mime_type }];
    }
    s.send(object);
  };

  static source_actions = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_data_offer>,
    source_actions: wl_data_device_manager_dnd_action,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event source_actions is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      source_actions & 0xff,
      (source_actions >> 8) & 0xff,
      (source_actions >> 16) & 0xff,
      (source_actions >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_offer";
      d.message_name = "source_actions";
      d.message_args = [
        {
          signature: "source_actions: wl_data_device_manager_dnd_action",
          value: source_actions,
        },
      ];
    }
    s.send(object);
  };

  static action = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_data_offer>,
    dnd_action: wl_data_device_manager_dnd_action,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event action is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      dnd_action & 0xff,
      (dnd_action >> 8) & 0xff,
      (dnd_action >> 16) & 0xff,
      (dnd_action >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_offer";
      d.message_name = "action";
      d.message_args = [
        {
          signature: "dnd_action: wl_data_device_manager_dnd_action",
          value: dnd_action,
        },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const mime_type_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const mime_type = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + mime_type_length - 1,
            ),
          ),
        );
        if (mime_type_length % 4 !== 0) {
          _data_in_offset__ += mime_type_length + (4 - (mime_type_length % 4));
        } else {
          _data_in_offset__ += mime_type_length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_offer@${message.object_id}.accept(`,
            "serial: ",
            serial,
            ", ",
            "mime_type: ",
            mime_type,
            ")",
          );
        }

        this.delegate.wl_data_offer_accept(
          s,
          message.object_id as any,
          serial as any,
          mime_type as any,
        );

        break;
      }

      case 1: {
        const mime_type_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const mime_type = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + mime_type_length - 1,
            ),
          ),
        );
        if (mime_type_length % 4 !== 0) {
          _data_in_offset__ += mime_type_length + (4 - (mime_type_length % 4));
        } else {
          _data_in_offset__ += mime_type_length;
        }

        const fd = s.claim_file_descriptor();

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_offer@${message.object_id}.receive(`,
            "mime_type: ",
            mime_type,
            ", ",
            "fd: ",
            fd,
            ")",
          );
        }

        this.delegate.wl_data_offer_receive(
          s,
          message.object_id as any,
          mime_type as any,
          fd as any,
        );

        break;
      }

      case 2: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_offer@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_data_offer_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 3: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_offer@${message.object_id}.finish(`,
            ")",
          );
        }

        this.delegate.wl_data_offer_finish(s, message.object_id as any);

        break;
      }

      case 4: {
        const dnd_actions =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const preferred_action =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_offer@${message.object_id}.set_actions(`,
            "dnd_actions: ",
            dnd_actions,
            ", ",
            "preferred_action: ",
            preferred_action,
            ")",
          );
        }

        this.delegate.wl_data_offer_set_actions(
          s,
          message.object_id as any,
          dnd_actions as any,
          preferred_action as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_data_offer", message.opcode);
        break;
    }
  };
}
export enum wl_data_offer_error {
  invalid_finish = 0,
  invalid_action_mask = 1,
  invalid_action = 2,
  invalid_offer = 3,
}

export interface wl_data_source_delegate {
  wl_data_source_offer: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_source>,
    mime_type: string,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_data_source_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_source>,
  ) => boolean;

  wl_data_source_set_actions: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_source>,
    dnd_actions: wl_data_device_manager_dnd_action,
  ) => void;

  wl_data_source_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_data_source>,
    interface_: string,
    new_id: Object_ID<wl_data_source>,
    version_number: version,
  ) => void;
}

export class wl_data_source {
  constructor(public delegate: wl_data_source_delegate) {}

  static target = (
    s: Sender,
    event_object_id: Object_ID<wl_data_source>,
    mime_type: string,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const mime_type_utf8 = new TextEncoder().encode(mime_type);
    const mime_type_total_length = mime_type_utf8.length + 1;
    data.push(
      mime_type_total_length & 0xff,
      (mime_type_total_length >> 8) & 0xff,
      (mime_type_total_length >> 16) & 0xff,
      (mime_type_total_length >> 24) & 0xff,
    );
    data.push(...mime_type_utf8);
    data.push(0); /* Null terminator */
    if (mime_type_total_length % 4 !== 0) {
      const padding = 4 - (mime_type_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "target";
      d.message_args = [{ signature: "mime_type: string", value: mime_type }];
    }
    s.send(object);
  };

  static send = (
    s: Sender,
    event_object_id: Object_ID<wl_data_source>,
    mime_type: string,
    fd: Exclude<File_Descriptor, null>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const mime_type_utf8 = new TextEncoder().encode(mime_type);
    const mime_type_total_length = mime_type_utf8.length + 1;
    data.push(
      mime_type_total_length & 0xff,
      (mime_type_total_length >> 8) & 0xff,
      (mime_type_total_length >> 16) & 0xff,
      (mime_type_total_length >> 24) & 0xff,
    );
    data.push(...mime_type_utf8);
    data.push(0); /* Null terminator */
    if (mime_type_total_length % 4 !== 0) {
      const padding = 4 - (mime_type_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    file_descriptor = fd;
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "send";
      d.message_args = [
        { signature: "mime_type: string", value: mime_type },
        { signature: "fd: Exclude<File_Descriptor,null>", value: fd },
      ];
    }
    s.send(object);
  };

  static cancelled = (
    s: Sender,
    event_object_id: Object_ID<wl_data_source>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "cancelled";
      d.message_args = [];
    }
    s.send(object);
  };

  static dnd_drop_performed = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_data_source>,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event dnd_drop_performed is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "dnd_drop_performed";
      d.message_args = [];
    }
    s.send(object);
  };

  static dnd_finished = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_data_source>,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event dnd_finished is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "dnd_finished";
      d.message_args = [];
    }
    s.send(object);
  };

  static action = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_data_source>,
    dnd_action: wl_data_device_manager_dnd_action,
  ) => {
    if (bound_version < 3) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event action is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      dnd_action & 0xff,
      (dnd_action >> 8) & 0xff,
      (dnd_action >> 16) & 0xff,
      (dnd_action >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_source";
      d.message_name = "action";
      d.message_args = [
        {
          signature: "dnd_action: wl_data_device_manager_dnd_action",
          value: dnd_action,
        },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const mime_type_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const mime_type = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + mime_type_length - 1,
            ),
          ),
        );
        if (mime_type_length % 4 !== 0) {
          _data_in_offset__ += mime_type_length + (4 - (mime_type_length % 4));
        } else {
          _data_in_offset__ += mime_type_length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_source@${message.object_id}.offer(`,
            "mime_type: ",
            mime_type,
            ")",
          );
        }

        this.delegate.wl_data_source_offer(
          s,
          message.object_id as any,
          mime_type as any,
        );

        break;
      }

      case 1: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_source@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_data_source_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 2: {
        const dnd_actions =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_source@${message.object_id}.set_actions(`,
            "dnd_actions: ",
            dnd_actions,
            ")",
          );
        }

        this.delegate.wl_data_source_set_actions(
          s,
          message.object_id as any,
          dnd_actions as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_data_source", message.opcode);
        break;
    }
  };
}
export enum wl_data_source_error {
  invalid_action_mask = 0,
  invalid_source = 1,
}

export interface wl_data_device_delegate {
  wl_data_device_start_drag: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_device>,
    source: Object_ID<wl_data_source> | null,
    origin: Object_ID<wl_surface>,
    icon: Object_ID<wl_surface> | null,
    serial: UInt32,
  ) => void;

  wl_data_device_set_selection: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_device>,
    source: Object_ID<wl_data_source> | null,
    serial: UInt32,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_data_device_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_device>,
  ) => boolean;

  wl_data_device_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_data_device>,
    interface_: string,
    new_id: Object_ID<wl_data_device>,
    version_number: version,
  ) => void;
}

export class wl_data_device {
  constructor(public delegate: wl_data_device_delegate) {}

  static data_offer = (
    s: Sender,
    event_object_id: Object_ID<wl_data_device>,
    id: Object_ID<wl_data_offer>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "data_offer";
      d.message_args = [
        { signature: "id: Object_ID<wl_data_offer>", value: id },
      ];
    }
    s.send(object);
  };

  static enter = (
    s: Sender,
    event_object_id: Object_ID<wl_data_device>,
    serial: UInt32,
    surface: Object_ID<wl_surface>,
    x: Fixed,
    y: Fixed,
    id: Object_ID<wl_data_offer> | null,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );
    const x_fixed = x * 256.0;
    data.push(
      x_fixed & 0xff,
      (x_fixed >> 8) & 0xff,
      (x_fixed >> 16) & 0xff,
      (x_fixed >> 24) & 0xff,
    );

    const y_fixed = y * 256.0;
    data.push(
      y_fixed & 0xff,
      (y_fixed >> 8) & 0xff,
      (y_fixed >> 16) & 0xff,
      (y_fixed >> 24) & 0xff,
    );

    const __temp_id = id ?? 0;
    data.push(
      __temp_id & 0xff,
      (__temp_id >> 8) & 0xff,
      (__temp_id >> 16) & 0xff,
      (__temp_id >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "enter";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
        { signature: "x: Fixed", value: x },
        { signature: "y: Fixed", value: y },
        { signature: "id: Object_ID<wl_data_offer>  | null ", value: id },
      ];
    }
    s.send(object);
  };

  static leave = (s: Sender, event_object_id: Object_ID<wl_data_device>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "leave";
      d.message_args = [];
    }
    s.send(object);
  };

  static motion = (
    s: Sender,
    event_object_id: Object_ID<wl_data_device>,
    time: UInt32,
    x: Fixed,
    y: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    const x_fixed = x * 256.0;
    data.push(
      x_fixed & 0xff,
      (x_fixed >> 8) & 0xff,
      (x_fixed >> 16) & 0xff,
      (x_fixed >> 24) & 0xff,
    );

    const y_fixed = y * 256.0;
    data.push(
      y_fixed & 0xff,
      (y_fixed >> 8) & 0xff,
      (y_fixed >> 16) & 0xff,
      (y_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "motion";
      d.message_args = [
        { signature: "time: UInt32", value: time },
        { signature: "x: Fixed", value: x },
        { signature: "y: Fixed", value: y },
      ];
    }
    s.send(object);
  };

  static drop = (s: Sender, event_object_id: Object_ID<wl_data_device>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "drop";
      d.message_args = [];
    }
    s.send(object);
  };

  static selection = (
    s: Sender,
    event_object_id: Object_ID<wl_data_device>,
    id: Object_ID<wl_data_offer> | null,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    const __temp_id = id ?? 0;
    data.push(
      __temp_id & 0xff,
      (__temp_id >> 8) & 0xff,
      (__temp_id >> 16) & 0xff,
      (__temp_id >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_data_device";
      d.message_name = "selection";
      d.message_args = [
        { signature: "id: Object_ID<wl_data_offer>  | null ", value: id },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const __temp_source =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const source = __temp_source === 0 ? null : __temp_source;

        const origin =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const __temp_icon =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const icon = __temp_icon === 0 ? null : __temp_icon;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_device@${message.object_id}.start_drag(`,
            "source: ",
            source,
            ", ",
            "origin: ",
            origin,
            ", ",
            "icon: ",
            icon,
            ", ",
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.wl_data_device_start_drag(
          s,
          message.object_id as any,
          source as any,
          origin as any,
          icon as any,
          serial as any,
        );

        break;
      }

      case 1: {
        const __temp_source =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const source = __temp_source === 0 ? null : __temp_source;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_device@${message.object_id}.set_selection(`,
            "source: ",
            source,
            ", ",
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.wl_data_device_set_selection(
          s,
          message.object_id as any,
          source as any,
          serial as any,
        );

        break;
      }

      case 2: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_device@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_data_device_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(
            Global_Ids.wl_data_device,
            message.object_id as any,
          );
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_data_device", message.opcode);
        break;
    }
  };
}
export enum wl_data_device_error {
  role = 0,
  used_source = 1,
}

export interface wl_data_device_manager_delegate {
  wl_data_device_manager_create_data_source: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_device_manager>,
    id: Object_ID<wl_data_source>,
  ) => void;

  wl_data_device_manager_get_data_device: (
    s: Wayland_Client,
    object_id: Object_ID<wl_data_device_manager>,
    id: Object_ID<wl_data_device>,
    seat: Object_ID<wl_seat>,
  ) => void;

  wl_data_device_manager_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_data_device_manager>,
    interface_: string,
    new_id: Object_ID<wl_data_device_manager>,
    version_number: version,
  ) => void;
}

export class wl_data_device_manager {
  constructor(public delegate: wl_data_device_manager_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_device_manager@${message.object_id}.create_data_source(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_data_device_manager_create_data_source(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_data_device_manager@${message.object_id}.get_data_device(`,
            "id: ",
            id,
            ", ",
            "seat: ",
            seat,
            ")",
          );
        }

        this.delegate.wl_data_device_manager_get_data_device(
          s,
          message.object_id as any,
          id as any,
          seat as any,
        );

        break;
      }

      default:
        console.error(
          "Unknown opcode on wl_data_device_manager",
          message.opcode,
        );
        break;
    }
  };
}
export enum wl_data_device_manager_dnd_action {
  none = 0,
  copy = 1,
  move = 2,
  ask = 4,
}

export interface wl_shell_delegate {
  wl_shell_get_shell_surface: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell>,
    id: Object_ID<wl_shell_surface>,
    surface: Object_ID<wl_surface>,
  ) => void;

  wl_shell_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_shell>,
    interface_: string,
    new_id: Object_ID<wl_shell>,
    version_number: version,
  ) => void;
}

export class wl_shell {
  constructor(public delegate: wl_shell_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell@${message.object_id}.get_shell_surface(`,
            "id: ",
            id,
            ", ",
            "surface: ",
            surface,
            ")",
          );
        }

        this.delegate.wl_shell_get_shell_surface(
          s,
          message.object_id as any,
          id as any,
          surface as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_shell", message.opcode);
        break;
    }
  };
}
export enum wl_shell_error {
  role = 0,
}

export interface wl_shell_surface_delegate {
  wl_shell_surface_pong: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    serial: UInt32,
  ) => void;

  wl_shell_surface_move: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
  ) => void;

  wl_shell_surface_resize: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
    edges: wl_shell_surface_resize,
  ) => void;

  wl_shell_surface_set_toplevel: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
  ) => void;

  wl_shell_surface_set_transient: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    parent: Object_ID<wl_surface>,
    x: Int32,
    y: Int32,
    flags: wl_shell_surface_transient,
  ) => void;

  wl_shell_surface_set_fullscreen: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    method: wl_shell_surface_fullscreen_method,
    framerate: UInt32,
    output: Object_ID<wl_output> | null,
  ) => void;

  wl_shell_surface_set_popup: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    seat: Object_ID<wl_seat>,
    serial: UInt32,
    parent: Object_ID<wl_surface>,
    x: Int32,
    y: Int32,
    flags: wl_shell_surface_transient,
  ) => void;

  wl_shell_surface_set_maximized: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    output: Object_ID<wl_output> | null,
  ) => void;

  wl_shell_surface_set_title: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    title: string,
  ) => void;

  wl_shell_surface_set_class: (
    s: Wayland_Client,
    object_id: Object_ID<wl_shell_surface>,
    class_: string,
  ) => void;

  wl_shell_surface_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_shell_surface>,
    interface_: string,
    new_id: Object_ID<wl_shell_surface>,
    version_number: version,
  ) => void;
}

export class wl_shell_surface {
  constructor(public delegate: wl_shell_surface_delegate) {}

  static ping = (
    s: Sender,
    event_object_id: Object_ID<wl_shell_surface>,
    serial: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_shell_surface";
      d.message_name = "ping";
      d.message_args = [{ signature: "serial: UInt32", value: serial }];
    }
    s.send(object);
  };

  static configure = (
    s: Sender,
    event_object_id: Object_ID<wl_shell_surface>,
    edges: wl_shell_surface_resize,
    width: Int32,
    height: Int32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      edges & 0xff,
      (edges >> 8) & 0xff,
      (edges >> 16) & 0xff,
      (edges >> 24) & 0xff,
    );
    data.push(
      width & 0xff,
      (width >> 8) & 0xff,
      (width >> 16) & 0xff,
      (width >> 24) & 0xff,
    );
    data.push(
      height & 0xff,
      (height >> 8) & 0xff,
      (height >> 16) & 0xff,
      (height >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_shell_surface";
      d.message_name = "configure";
      d.message_args = [
        { signature: "edges: wl_shell_surface_resize", value: edges },
        { signature: "width: Int32", value: width },
        { signature: "height: Int32", value: height },
      ];
    }
    s.send(object);
  };

  static popup_done = (
    s: Sender,
    event_object_id: Object_ID<wl_shell_surface>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_shell_surface";
      d.message_name = "popup_done";
      d.message_args = [];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.pong(`,
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.wl_shell_surface_pong(
          s,
          message.object_id as any,
          serial as any,
        );

        break;
      }

      case 1: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.move(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ")",
          );
        }

        this.delegate.wl_shell_surface_move(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
        );

        break;
      }

      case 2: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const edges =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.resize(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ", ",
            "edges: ",
            edges,
            ")",
          );
        }

        this.delegate.wl_shell_surface_resize(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
          edges as any,
        );

        break;
      }

      case 3: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_toplevel(`,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_toplevel(
          s,
          message.object_id as any,
        );

        break;
      }

      case 4: {
        const parent =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const flags =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_transient(`,
            "parent: ",
            parent,
            ", ",
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "flags: ",
            flags,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_transient(
          s,
          message.object_id as any,
          parent as any,
          x as any,
          y as any,
          flags as any,
        );

        break;
      }

      case 5: {
        const method =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const framerate =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const __temp_output =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const output = __temp_output === 0 ? null : __temp_output;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_fullscreen(`,
            "method: ",
            method,
            ", ",
            "framerate: ",
            framerate,
            ", ",
            "output: ",
            output,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_fullscreen(
          s,
          message.object_id as any,
          method as any,
          framerate as any,
          output as any,
        );

        break;
      }

      case 6: {
        const seat =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const parent =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const flags =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_popup(`,
            "seat: ",
            seat,
            ", ",
            "serial: ",
            serial,
            ", ",
            "parent: ",
            parent,
            ", ",
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "flags: ",
            flags,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_popup(
          s,
          message.object_id as any,
          seat as any,
          serial as any,
          parent as any,
          x as any,
          y as any,
          flags as any,
        );

        break;
      }

      case 7: {
        const __temp_output =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const output = __temp_output === 0 ? null : __temp_output;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_maximized(`,
            "output: ",
            output,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_maximized(
          s,
          message.object_id as any,
          output as any,
        );

        break;
      }

      case 8: {
        const title_length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const title = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + title_length - 1,
            ),
          ),
        );
        if (title_length % 4 !== 0) {
          _data_in_offset__ += title_length + (4 - (title_length % 4));
        } else {
          _data_in_offset__ += title_length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_title(`,
            "title: ",
            title,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_title(
          s,
          message.object_id as any,
          title as any,
        );

        break;
      }

      case 9: {
        const class__length =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;
        const class_ = new TextDecoder().decode(
          new Uint8Array(
            message.data.slice(
              _data_in_offset__,
              _data_in_offset__ + class__length - 1,
            ),
          ),
        );
        if (class__length % 4 !== 0) {
          _data_in_offset__ += class__length + (4 - (class__length % 4));
        } else {
          _data_in_offset__ += class__length;
        }

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_shell_surface@${message.object_id}.set_class(`,
            "class_: ",
            class_,
            ")",
          );
        }

        this.delegate.wl_shell_surface_set_class(
          s,
          message.object_id as any,
          class_ as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_shell_surface", message.opcode);
        break;
    }
  };
}
export enum wl_shell_surface_resize {
  none = 0,
  top = 1,
  bottom = 2,
  left = 4,
  top_left = 5,
  bottom_left = 6,
  right = 8,
  top_right = 9,
  bottom_right = 10,
}
export enum wl_shell_surface_transient {
  inactive = 0x1,
}
export enum wl_shell_surface_fullscreen_method {
  default = 0,
  scale = 1,
  driver = 2,
  fill = 3,
}

export interface wl_surface_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_surface_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
  ) => boolean;

  wl_surface_attach: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    buffer: Object_ID<wl_buffer> | null,
    x: Int32,
    y: Int32,
  ) => void;

  wl_surface_damage: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  wl_surface_frame: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    callback: Object_ID<wl_callback>,
  ) => void;

  wl_surface_set_opaque_region: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    region: Object_ID<wl_region> | null,
  ) => void;

  wl_surface_set_input_region: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    region: Object_ID<wl_region> | null,
  ) => void;

  wl_surface_commit: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
  ) => void;

  wl_surface_set_buffer_transform: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    transform: Int32,
  ) => void;

  wl_surface_set_buffer_scale: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    scale: Int32,
  ) => void;

  wl_surface_damage_buffer: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  wl_surface_offset: (
    s: Wayland_Client,
    object_id: Object_ID<wl_surface>,
    x: Int32,
    y: Int32,
  ) => void;

  wl_surface_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_surface>,
    interface_: string,
    new_id: Object_ID<wl_surface>,
    version_number: version,
  ) => void;
}

export class wl_surface {
  constructor(public delegate: wl_surface_delegate) {}

  static enter = (
    s: Sender,
    event_object_id: Object_ID<wl_surface>,
    output: Object_ID<wl_output>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      output & 0xff,
      (output >> 8) & 0xff,
      (output >> 16) & 0xff,
      (output >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_surface";
      d.message_name = "enter";
      d.message_args = [
        { signature: "output: Object_ID<wl_output>   ", value: output },
      ];
    }
    s.send(object);
  };

  static leave = (
    s: Sender,
    event_object_id: Object_ID<wl_surface>,
    output: Object_ID<wl_output>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      output & 0xff,
      (output >> 8) & 0xff,
      (output >> 16) & 0xff,
      (output >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_surface";
      d.message_name = "leave";
      d.message_args = [
        { signature: "output: Object_ID<wl_output>   ", value: output },
      ];
    }
    s.send(object);
  };

  static preferred_buffer_scale = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_surface>,
    factor: Int32,
  ) => {
    if (bound_version < 6) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event preferred_buffer_scale is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      factor & 0xff,
      (factor >> 8) & 0xff,
      (factor >> 16) & 0xff,
      (factor >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_surface";
      d.message_name = "preferred_buffer_scale";
      d.message_args = [{ signature: "factor: Int32", value: factor }];
    }
    s.send(object);
  };

  static preferred_buffer_transform = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_surface>,
    transform: wl_output_transform,
  ) => {
    if (bound_version < 6) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event preferred_buffer_transform is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      transform & 0xff,
      (transform >> 8) & 0xff,
      (transform >> 16) & 0xff,
      (transform >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_surface";
      d.message_name = "preferred_buffer_transform";
      d.message_args = [
        { signature: "transform: wl_output_transform", value: transform },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_surface_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const __temp_buffer =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const buffer = __temp_buffer === 0 ? null : __temp_buffer;

        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.attach(`,
            "buffer: ",
            buffer,
            ", ",
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ")",
          );
        }

        this.delegate.wl_surface_attach(
          s,
          message.object_id as any,
          buffer as any,
          x as any,
          y as any,
        );

        break;
      }

      case 2: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.damage(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.wl_surface_damage(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      case 3: {
        const callback =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.frame(`,
            "callback: ",
            callback,
            ")",
          );
        }

        this.delegate.wl_surface_frame(
          s,
          message.object_id as any,
          callback as any,
        );

        break;
      }

      case 4: {
        const __temp_region =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const region = __temp_region === 0 ? null : __temp_region;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.set_opaque_region(`,
            "region: ",
            region,
            ")",
          );
        }

        this.delegate.wl_surface_set_opaque_region(
          s,
          message.object_id as any,
          region as any,
        );

        break;
      }

      case 5: {
        const __temp_region =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const region = __temp_region === 0 ? null : __temp_region;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.set_input_region(`,
            "region: ",
            region,
            ")",
          );
        }

        this.delegate.wl_surface_set_input_region(
          s,
          message.object_id as any,
          region as any,
        );

        break;
      }

      case 6: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.commit(`,
            ")",
          );
        }

        this.delegate.wl_surface_commit(s, message.object_id as any);

        break;
      }

      case 7: {
        const transform =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.set_buffer_transform(`,
            "transform: ",
            transform,
            ")",
          );
        }

        this.delegate.wl_surface_set_buffer_transform(
          s,
          message.object_id as any,
          transform as any,
        );

        break;
      }

      case 8: {
        const scale =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.set_buffer_scale(`,
            "scale: ",
            scale,
            ")",
          );
        }

        this.delegate.wl_surface_set_buffer_scale(
          s,
          message.object_id as any,
          scale as any,
        );

        break;
      }

      case 9: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.damage_buffer(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.wl_surface_damage_buffer(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      case 10: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_surface@${message.object_id}.offset(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ")",
          );
        }

        this.delegate.wl_surface_offset(
          s,
          message.object_id as any,
          x as any,
          y as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_surface", message.opcode);
        break;
    }
  };
}
export enum wl_surface_error {
  invalid_scale = 0,
  invalid_transform = 1,
  invalid_size = 2,
  invalid_offset = 3,
  defunct_role_object = 4,
}

export interface wl_seat_delegate {
  wl_seat_get_pointer: (
    s: Wayland_Client,
    object_id: Object_ID<wl_seat>,
    id: Object_ID<wl_pointer>,
  ) => void;

  wl_seat_get_keyboard: (
    s: Wayland_Client,
    object_id: Object_ID<wl_seat>,
    id: Object_ID<wl_keyboard>,
  ) => void;

  wl_seat_get_touch: (
    s: Wayland_Client,
    object_id: Object_ID<wl_seat>,
    id: Object_ID<wl_touch>,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_seat_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_seat>,
  ) => boolean;

  wl_seat_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_seat>,
    interface_: string,
    new_id: Object_ID<wl_seat>,
    version_number: version,
  ) => void;
}

export class wl_seat {
  constructor(public delegate: wl_seat_delegate) {}

  static capabilities = (
    s: Sender,
    event_object_id: Object_ID<wl_seat>,
    capabilities: wl_seat_capability,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      capabilities & 0xff,
      (capabilities >> 8) & 0xff,
      (capabilities >> 16) & 0xff,
      (capabilities >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_seat";
      d.message_name = "capabilities";
      d.message_args = [
        { signature: "capabilities: wl_seat_capability", value: capabilities },
      ];
    }
    s.send(object);
  };

  static name = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_seat>,
    name: string,
  ) => {
    if (bound_version < 2) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event name is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const name_utf8 = new TextEncoder().encode(name);
    const name_total_length = name_utf8.length + 1;
    data.push(
      name_total_length & 0xff,
      (name_total_length >> 8) & 0xff,
      (name_total_length >> 16) & 0xff,
      (name_total_length >> 24) & 0xff,
    );
    data.push(...name_utf8);
    data.push(0); /* Null terminator */
    if (name_total_length % 4 !== 0) {
      const padding = 4 - (name_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_seat";
      d.message_name = "name";
      d.message_args = [{ signature: "name: string", value: name }];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_seat@${message.object_id}.get_pointer(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_seat_get_pointer(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_seat@${message.object_id}.get_keyboard(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_seat_get_keyboard(
          s,
          message.object_id as any,
          id as any,
        );

        break;
      }

      case 2: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_seat@${message.object_id}.get_touch(`,
            "id: ",
            id,
            ")",
          );
        }

        this.delegate.wl_seat_get_touch(s, message.object_id as any, id as any);

        break;
      }

      case 3: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_seat@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_seat_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(Global_Ids.wl_seat, message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_seat", message.opcode);
        break;
    }
  };
}
export enum wl_seat_capability {
  pointer = 1,
  keyboard = 2,
  touch = 4,
}
export enum wl_seat_error {
  missing_capability = 0,
}

export interface wl_pointer_delegate {
  wl_pointer_set_cursor: (
    s: Wayland_Client,
    object_id: Object_ID<wl_pointer>,
    serial: UInt32,
    surface: Object_ID<wl_surface> | null,
    hotspot_x: Int32,
    hotspot_y: Int32,
  ) => void;

  /** @returns true if we should auto remove the object after destruction */
  wl_pointer_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_pointer>,
  ) => boolean;

  wl_pointer_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_pointer>,
    interface_: string,
    new_id: Object_ID<wl_pointer>,
    version_number: version,
  ) => void;

  after_get_pointer: (
    s: Wayland_Client,
    object_id: Object_ID<wl_pointer>,
  ) => void;
}

export class wl_pointer {
  constructor(public delegate: wl_pointer_delegate) {}

  static enter = (
    s: Sender,
    event_object_id: Object_ID<wl_pointer>,
    serial: UInt32,
    surface: Object_ID<wl_surface>,
    surface_x: Fixed,
    surface_y: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );
    const surface_x_fixed = surface_x * 256.0;
    data.push(
      surface_x_fixed & 0xff,
      (surface_x_fixed >> 8) & 0xff,
      (surface_x_fixed >> 16) & 0xff,
      (surface_x_fixed >> 24) & 0xff,
    );

    const surface_y_fixed = surface_y * 256.0;
    data.push(
      surface_y_fixed & 0xff,
      (surface_y_fixed >> 8) & 0xff,
      (surface_y_fixed >> 16) & 0xff,
      (surface_y_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "enter";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
        { signature: "surface_x: Fixed", value: surface_x },
        { signature: "surface_y: Fixed", value: surface_y },
      ];
    }
    s.send(object);
  };

  static leave = (
    s: Sender,
    event_object_id: Object_ID<wl_pointer>,
    serial: UInt32,
    surface: Object_ID<wl_surface>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "leave";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
      ];
    }
    s.send(object);
  };

  static motion = (
    s: Sender,
    event_object_id: Object_ID<wl_pointer>,
    time: UInt32,
    surface_x: Fixed,
    surface_y: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    const surface_x_fixed = surface_x * 256.0;
    data.push(
      surface_x_fixed & 0xff,
      (surface_x_fixed >> 8) & 0xff,
      (surface_x_fixed >> 16) & 0xff,
      (surface_x_fixed >> 24) & 0xff,
    );

    const surface_y_fixed = surface_y * 256.0;
    data.push(
      surface_y_fixed & 0xff,
      (surface_y_fixed >> 8) & 0xff,
      (surface_y_fixed >> 16) & 0xff,
      (surface_y_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "motion";
      d.message_args = [
        { signature: "time: UInt32", value: time },
        { signature: "surface_x: Fixed", value: surface_x },
        { signature: "surface_y: Fixed", value: surface_y },
      ];
    }
    s.send(object);
  };

  static button = (
    s: Sender,
    event_object_id: Object_ID<wl_pointer>,
    serial: UInt32,
    time: UInt32,
    button: UInt32,
    state: wl_pointer_button_state,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      button & 0xff,
      (button >> 8) & 0xff,
      (button >> 16) & 0xff,
      (button >> 24) & 0xff,
    );
    data.push(
      state & 0xff,
      (state >> 8) & 0xff,
      (state >> 16) & 0xff,
      (state >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "button";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "time: UInt32", value: time },
        { signature: "button: UInt32", value: button },
        { signature: "state: wl_pointer_button_state", value: state },
      ];
    }
    s.send(object);
  };

  static axis = (
    s: Sender,
    event_object_id: Object_ID<wl_pointer>,
    time: UInt32,
    axis: wl_pointer_axis,
    value: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      axis & 0xff,
      (axis >> 8) & 0xff,
      (axis >> 16) & 0xff,
      (axis >> 24) & 0xff,
    );
    const value_fixed = value * 256.0;
    data.push(
      value_fixed & 0xff,
      (value_fixed >> 8) & 0xff,
      (value_fixed >> 16) & 0xff,
      (value_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis";
      d.message_args = [
        { signature: "time: UInt32", value: time },
        { signature: "axis: wl_pointer_axis", value: axis },
        { signature: "value: Fixed", value: value },
      ];
    }
    s.send(object);
  };

  static frame = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
  ) => {
    if (bound_version < 5) {
      if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
        console.error(
          "Event frame is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "frame";
      d.message_args = [];
    }
    s.send(object);
  };

  static axis_source = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
    axis_source: wl_pointer_axis_source,
  ) => {
    if (bound_version < 5) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event axis_source is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      axis_source & 0xff,
      (axis_source >> 8) & 0xff,
      (axis_source >> 16) & 0xff,
      (axis_source >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 6,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis_source";
      d.message_args = [
        {
          signature: "axis_source: wl_pointer_axis_source",
          value: axis_source,
        },
      ];
    }
    s.send(object);
  };

  static axis_stop = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
    time: UInt32,
    axis: wl_pointer_axis,
  ) => {
    if (bound_version < 5) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event axis_stop is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      axis & 0xff,
      (axis >> 8) & 0xff,
      (axis >> 16) & 0xff,
      (axis >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 7,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis_stop";
      d.message_args = [
        { signature: "time: UInt32", value: time },
        { signature: "axis: wl_pointer_axis", value: axis },
      ];
    }
    s.send(object);
  };

  static axis_discrete = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
    axis: wl_pointer_axis,
    discrete: Int32,
  ) => {
    if (bound_version < 5) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event axis_discrete is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      axis & 0xff,
      (axis >> 8) & 0xff,
      (axis >> 16) & 0xff,
      (axis >> 24) & 0xff,
    );
    data.push(
      discrete & 0xff,
      (discrete >> 8) & 0xff,
      (discrete >> 16) & 0xff,
      (discrete >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 8,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis_discrete";
      d.message_args = [
        { signature: "axis: wl_pointer_axis", value: axis },
        { signature: "discrete: Int32", value: discrete },
      ];
    }
    s.send(object);
  };

  static axis_value120 = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
    axis: wl_pointer_axis,
    value120: Int32,
  ) => {
    if (bound_version < 8) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event axis_value120 is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      axis & 0xff,
      (axis >> 8) & 0xff,
      (axis >> 16) & 0xff,
      (axis >> 24) & 0xff,
    );
    data.push(
      value120 & 0xff,
      (value120 >> 8) & 0xff,
      (value120 >> 16) & 0xff,
      (value120 >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 9,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis_value120";
      d.message_args = [
        { signature: "axis: wl_pointer_axis", value: axis },
        { signature: "value120: Int32", value: value120 },
      ];
    }
    s.send(object);
  };

  static axis_relative_direction = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_pointer>,
    axis: wl_pointer_axis,
    direction: wl_pointer_axis_relative_direction,
  ) => {
    if (bound_version < 9) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event axis_relative_direction is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      axis & 0xff,
      (axis >> 8) & 0xff,
      (axis >> 16) & 0xff,
      (axis >> 24) & 0xff,
    );
    data.push(
      direction & 0xff,
      (direction >> 8) & 0xff,
      (direction >> 16) & 0xff,
      (direction >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 10,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_pointer";
      d.message_name = "axis_relative_direction";
      d.message_args = [
        { signature: "axis: wl_pointer_axis", value: axis },
        {
          signature: "direction: wl_pointer_axis_relative_direction",
          value: direction,
        },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        const serial =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const __temp_surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface = __temp_surface === 0 ? null : __temp_surface;

        const hotspot_x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const hotspot_y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_pointer@${message.object_id}.set_cursor(`,
            "serial: ",
            serial,
            ", ",
            "surface: ",
            surface,
            ", ",
            "hotspot_x: ",
            hotspot_x,
            ", ",
            "hotspot_y: ",
            hotspot_y,
            ")",
          );
        }

        this.delegate.wl_pointer_set_cursor(
          s,
          message.object_id as any,
          serial as any,
          surface as any,
          hotspot_x as any,
          hotspot_y as any,
        );

        break;
      }

      case 1: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_pointer@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_pointer_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(Global_Ids.wl_pointer, message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_pointer", message.opcode);
        break;
    }
  };
}
export enum wl_pointer_error {
  role = 0,
}
export enum wl_pointer_button_state {
  released = 0,
  pressed = 1,
}
export enum wl_pointer_axis {
  vertical_scroll = 0,
  horizontal_scroll = 1,
}
export enum wl_pointer_axis_source {
  wheel = 0,
  finger = 1,
  continuous = 2,
  wheel_tilt = 3,
}
export enum wl_pointer_axis_relative_direction {
  identical = 0,
  inverted = 1,
}

export interface wl_keyboard_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_keyboard_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_keyboard>,
  ) => boolean;

  wl_keyboard_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_keyboard>,
    interface_: string,
    new_id: Object_ID<wl_keyboard>,
    version_number: version,
  ) => void;

  after_get_keyboard: (
    s: Wayland_Client,
    object_id: Object_ID<wl_keyboard>,
  ) => void;
}

export class wl_keyboard {
  constructor(public delegate: wl_keyboard_delegate) {}

  static keymap = (
    s: Sender,
    event_object_id: Object_ID<wl_keyboard>,
    format: wl_keyboard_keymap_format,
    fd: Exclude<File_Descriptor, null>,
    size: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      format & 0xff,
      (format >> 8) & 0xff,
      (format >> 16) & 0xff,
      (format >> 24) & 0xff,
    );
    file_descriptor = fd;
    data.push(
      size & 0xff,
      (size >> 8) & 0xff,
      (size >> 16) & 0xff,
      (size >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "keymap";
      d.message_args = [
        { signature: "format: wl_keyboard_keymap_format", value: format },
        { signature: "fd: Exclude<File_Descriptor,null>", value: fd },
        { signature: "size: UInt32", value: size },
      ];
    }
    s.send(object);
  };

  static enter = (
    s: Sender,
    event_object_id: Object_ID<wl_keyboard>,
    serial: UInt32,
    surface: Object_ID<wl_surface>,
    keys: number[],
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );

    data.push(
      keys.length & 0xff,
      (keys.length >> 8) & 0xff,
      (keys.length >> 16) & 0xff,
      (keys.length >> 24) & 0xff,
    );
    data.push(...keys);
    if (keys.length % 4 !== 0) {
      const padding = 4 - (keys.length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "enter";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
        { signature: "keys: number[]", value: keys },
      ];
    }
    s.send(object);
  };

  static leave = (
    s: Sender,
    event_object_id: Object_ID<wl_keyboard>,
    serial: UInt32,
    surface: Object_ID<wl_surface>,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "leave";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
      ];
    }
    s.send(object);
  };

  static key = (
    s: Sender,
    event_object_id: Object_ID<wl_keyboard>,
    serial: UInt32,
    time: UInt32,
    key: UInt32,
    state: wl_keyboard_key_state,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      key & 0xff,
      (key >> 8) & 0xff,
      (key >> 16) & 0xff,
      (key >> 24) & 0xff,
    );
    data.push(
      state & 0xff,
      (state >> 8) & 0xff,
      (state >> 16) & 0xff,
      (state >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "key";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "time: UInt32", value: time },
        { signature: "key: UInt32", value: key },
        { signature: "state: wl_keyboard_key_state", value: state },
      ];
    }
    s.send(object);
  };

  static modifiers = (
    s: Sender,
    event_object_id: Object_ID<wl_keyboard>,
    serial: UInt32,
    mods_depressed: UInt32,
    mods_latched: UInt32,
    mods_locked: UInt32,
    group: UInt32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      mods_depressed & 0xff,
      (mods_depressed >> 8) & 0xff,
      (mods_depressed >> 16) & 0xff,
      (mods_depressed >> 24) & 0xff,
    );
    data.push(
      mods_latched & 0xff,
      (mods_latched >> 8) & 0xff,
      (mods_latched >> 16) & 0xff,
      (mods_latched >> 24) & 0xff,
    );
    data.push(
      mods_locked & 0xff,
      (mods_locked >> 8) & 0xff,
      (mods_locked >> 16) & 0xff,
      (mods_locked >> 24) & 0xff,
    );
    data.push(
      group & 0xff,
      (group >> 8) & 0xff,
      (group >> 16) & 0xff,
      (group >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "modifiers";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "mods_depressed: UInt32", value: mods_depressed },
        { signature: "mods_latched: UInt32", value: mods_latched },
        { signature: "mods_locked: UInt32", value: mods_locked },
        { signature: "group: UInt32", value: group },
      ];
    }
    s.send(object);
  };

  static repeat_info = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_keyboard>,
    rate: Int32,
    delay: Int32,
  ) => {
    if (bound_version < 4) {
      if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
        console.error(
          "Event repeat_info is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      rate & 0xff,
      (rate >> 8) & 0xff,
      (rate >> 16) & 0xff,
      (rate >> 24) & 0xff,
    );
    data.push(
      delay & 0xff,
      (delay >> 8) & 0xff,
      (delay >> 16) & 0xff,
      (delay >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_keyboard";
      d.message_name = "repeat_info";
      d.message_args = [
        { signature: "rate: Int32", value: rate },
        { signature: "delay: Int32", value: delay },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only() && show_wayland_surface_and_buffer()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_keyboard@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_keyboard_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(
            Global_Ids.wl_keyboard,
            message.object_id as any,
          );
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_keyboard", message.opcode);
        break;
    }
  };
}
export enum wl_keyboard_keymap_format {
  no_keymap = 0,
  xkb_v1 = 1,
}
export enum wl_keyboard_key_state {
  released = 0,
  pressed = 1,
}

export interface wl_touch_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_touch_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_touch>,
  ) => boolean;

  wl_touch_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_touch>,
    interface_: string,
    new_id: Object_ID<wl_touch>,
    version_number: version,
  ) => void;
}

export class wl_touch {
  constructor(public delegate: wl_touch_delegate) {}

  static down = (
    s: Sender,
    event_object_id: Object_ID<wl_touch>,
    serial: UInt32,
    time: UInt32,
    surface: Object_ID<wl_surface>,
    id: Int32,
    x: Fixed,
    y: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      surface & 0xff,
      (surface >> 8) & 0xff,
      (surface >> 16) & 0xff,
      (surface >> 24) & 0xff,
    );
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const x_fixed = x * 256.0;
    data.push(
      x_fixed & 0xff,
      (x_fixed >> 8) & 0xff,
      (x_fixed >> 16) & 0xff,
      (x_fixed >> 24) & 0xff,
    );

    const y_fixed = y * 256.0;
    data.push(
      y_fixed & 0xff,
      (y_fixed >> 8) & 0xff,
      (y_fixed >> 16) & 0xff,
      (y_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "down";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "time: UInt32", value: time },
        { signature: "surface: Object_ID<wl_surface>   ", value: surface },
        { signature: "id: Int32", value: id },
        { signature: "x: Fixed", value: x },
        { signature: "y: Fixed", value: y },
      ];
    }
    s.send(object);
  };

  static up = (
    s: Sender,
    event_object_id: Object_ID<wl_touch>,
    serial: UInt32,
    time: UInt32,
    id: Int32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      serial & 0xff,
      (serial >> 8) & 0xff,
      (serial >> 16) & 0xff,
      (serial >> 24) & 0xff,
    );
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "up";
      d.message_args = [
        { signature: "serial: UInt32", value: serial },
        { signature: "time: UInt32", value: time },
        { signature: "id: Int32", value: id },
      ];
    }
    s.send(object);
  };

  static motion = (
    s: Sender,
    event_object_id: Object_ID<wl_touch>,
    time: UInt32,
    id: Int32,
    x: Fixed,
    y: Fixed,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      time & 0xff,
      (time >> 8) & 0xff,
      (time >> 16) & 0xff,
      (time >> 24) & 0xff,
    );
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const x_fixed = x * 256.0;
    data.push(
      x_fixed & 0xff,
      (x_fixed >> 8) & 0xff,
      (x_fixed >> 16) & 0xff,
      (x_fixed >> 24) & 0xff,
    );

    const y_fixed = y * 256.0;
    data.push(
      y_fixed & 0xff,
      (y_fixed >> 8) & 0xff,
      (y_fixed >> 16) & 0xff,
      (y_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "motion";
      d.message_args = [
        { signature: "time: UInt32", value: time },
        { signature: "id: Int32", value: id },
        { signature: "x: Fixed", value: x },
        { signature: "y: Fixed", value: y },
      ];
    }
    s.send(object);
  };

  static frame = (s: Sender, event_object_id: Object_ID<wl_touch>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "frame";
      d.message_args = [];
    }
    s.send(object);
  };

  static cancel = (s: Sender, event_object_id: Object_ID<wl_touch>) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "cancel";
      d.message_args = [];
    }
    s.send(object);
  };

  static shape = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_touch>,
    id: Int32,
    major: Fixed,
    minor: Fixed,
  ) => {
    if (bound_version < 6) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event shape is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const major_fixed = major * 256.0;
    data.push(
      major_fixed & 0xff,
      (major_fixed >> 8) & 0xff,
      (major_fixed >> 16) & 0xff,
      (major_fixed >> 24) & 0xff,
    );

    const minor_fixed = minor * 256.0;
    data.push(
      minor_fixed & 0xff,
      (minor_fixed >> 8) & 0xff,
      (minor_fixed >> 16) & 0xff,
      (minor_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "shape";
      d.message_args = [
        { signature: "id: Int32", value: id },
        { signature: "major: Fixed", value: major },
        { signature: "minor: Fixed", value: minor },
      ];
    }
    s.send(object);
  };

  static orientation = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_touch>,
    id: Int32,
    orientation: Fixed,
  ) => {
    if (bound_version < 6) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event orientation is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      id & 0xff,
      (id >> 8) & 0xff,
      (id >> 16) & 0xff,
      (id >> 24) & 0xff,
    );
    const orientation_fixed = orientation * 256.0;
    data.push(
      orientation_fixed & 0xff,
      (orientation_fixed >> 8) & 0xff,
      (orientation_fixed >> 16) & 0xff,
      (orientation_fixed >> 24) & 0xff,
    );

    const object = {
      object_id: event_object_id,
      opcode: 6,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_touch";
      d.message_name = "orientation";
      d.message_args = [
        { signature: "id: Int32", value: id },
        { signature: "orientation: Fixed", value: orientation },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_touch@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_touch_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(Global_Ids.wl_touch, message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_touch", message.opcode);
        break;
    }
  };
}

export interface wl_output_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_output_release: (
    s: Wayland_Client,
    object_id: Object_ID<wl_output>,
  ) => boolean;

  wl_output_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_output>,
    interface_: string,
    new_id: Object_ID<wl_output>,
    version_number: version,
  ) => void;
}

export class wl_output {
  constructor(public delegate: wl_output_delegate) {}

  static geometry = (
    s: Sender,
    event_object_id: Object_ID<wl_output>,
    x: Int32,
    y: Int32,
    physical_width: Int32,
    physical_height: Int32,
    subpixel: Int32,
    make: string,
    model: string,
    transform: Int32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(x & 0xff, (x >> 8) & 0xff, (x >> 16) & 0xff, (x >> 24) & 0xff);
    data.push(y & 0xff, (y >> 8) & 0xff, (y >> 16) & 0xff, (y >> 24) & 0xff);
    data.push(
      physical_width & 0xff,
      (physical_width >> 8) & 0xff,
      (physical_width >> 16) & 0xff,
      (physical_width >> 24) & 0xff,
    );
    data.push(
      physical_height & 0xff,
      (physical_height >> 8) & 0xff,
      (physical_height >> 16) & 0xff,
      (physical_height >> 24) & 0xff,
    );
    data.push(
      subpixel & 0xff,
      (subpixel >> 8) & 0xff,
      (subpixel >> 16) & 0xff,
      (subpixel >> 24) & 0xff,
    );

    const make_utf8 = new TextEncoder().encode(make);
    const make_total_length = make_utf8.length + 1;
    data.push(
      make_total_length & 0xff,
      (make_total_length >> 8) & 0xff,
      (make_total_length >> 16) & 0xff,
      (make_total_length >> 24) & 0xff,
    );
    data.push(...make_utf8);
    data.push(0); /* Null terminator */
    if (make_total_length % 4 !== 0) {
      const padding = 4 - (make_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const model_utf8 = new TextEncoder().encode(model);
    const model_total_length = model_utf8.length + 1;
    data.push(
      model_total_length & 0xff,
      (model_total_length >> 8) & 0xff,
      (model_total_length >> 16) & 0xff,
      (model_total_length >> 24) & 0xff,
    );
    data.push(...model_utf8);
    data.push(0); /* Null terminator */
    if (model_total_length % 4 !== 0) {
      const padding = 4 - (model_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    data.push(
      transform & 0xff,
      (transform >> 8) & 0xff,
      (transform >> 16) & 0xff,
      (transform >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 0,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "geometry";
      d.message_args = [
        { signature: "x: Int32", value: x },
        { signature: "y: Int32", value: y },
        { signature: "physical_width: Int32", value: physical_width },
        { signature: "physical_height: Int32", value: physical_height },
        { signature: "subpixel: Int32", value: subpixel },
        { signature: "make: string", value: make },
        { signature: "model: string", value: model },
        { signature: "transform: Int32", value: transform },
      ];
    }
    s.send(object);
  };

  static mode = (
    s: Sender,
    event_object_id: Object_ID<wl_output>,
    flags: wl_output_mode,
    width: Int32,
    height: Int32,
    refresh: Int32,
  ) => {
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      flags & 0xff,
      (flags >> 8) & 0xff,
      (flags >> 16) & 0xff,
      (flags >> 24) & 0xff,
    );
    data.push(
      width & 0xff,
      (width >> 8) & 0xff,
      (width >> 16) & 0xff,
      (width >> 24) & 0xff,
    );
    data.push(
      height & 0xff,
      (height >> 8) & 0xff,
      (height >> 16) & 0xff,
      (height >> 24) & 0xff,
    );
    data.push(
      refresh & 0xff,
      (refresh >> 8) & 0xff,
      (refresh >> 16) & 0xff,
      (refresh >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 1,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "mode";
      d.message_args = [
        { signature: "flags: wl_output_mode", value: flags },
        { signature: "width: Int32", value: width },
        { signature: "height: Int32", value: height },
        { signature: "refresh: Int32", value: refresh },
      ];
    }
    s.send(object);
  };

  static done = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_output>,
  ) => {
    if (bound_version < 2) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event done is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const object = {
      object_id: event_object_id,
      opcode: 2,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "done";
      d.message_args = [];
    }
    s.send(object);
  };

  static scale = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_output>,
    factor: Int32,
  ) => {
    if (bound_version < 2) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event scale is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;
    data.push(
      factor & 0xff,
      (factor >> 8) & 0xff,
      (factor >> 16) & 0xff,
      (factor >> 24) & 0xff,
    );
    const object = {
      object_id: event_object_id,
      opcode: 3,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "scale";
      d.message_args = [{ signature: "factor: Int32", value: factor }];
    }
    s.send(object);
  };

  static name = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_output>,
    name: string,
  ) => {
    if (bound_version < 4) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event name is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const name_utf8 = new TextEncoder().encode(name);
    const name_total_length = name_utf8.length + 1;
    data.push(
      name_total_length & 0xff,
      (name_total_length >> 8) & 0xff,
      (name_total_length >> 16) & 0xff,
      (name_total_length >> 24) & 0xff,
    );
    data.push(...name_utf8);
    data.push(0); /* Null terminator */
    if (name_total_length % 4 !== 0) {
      const padding = 4 - (name_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 4,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "name";
      d.message_args = [{ signature: "name: string", value: name }];
    }
    s.send(object);
  };

  static description = (
    s: Sender,
    bound_version: version,
    event_object_id: Object_ID<wl_output>,
    description: string,
  ) => {
    if (bound_version < 4) {
      if (wayland_debug_time_only()) {
        console.error(
          "Event description is not available in version, skipping",
          bound_version,
        );
      }
      return;
    }
    let data: number[] = [];
    let file_descriptor: undefined | File_Descriptor = undefined;

    const description_utf8 = new TextEncoder().encode(description);
    const description_total_length = description_utf8.length + 1;
    data.push(
      description_total_length & 0xff,
      (description_total_length >> 8) & 0xff,
      (description_total_length >> 16) & 0xff,
      (description_total_length >> 24) & 0xff,
    );
    data.push(...description_utf8);
    data.push(0); /* Null terminator */
    if (description_total_length % 4 !== 0) {
      const padding = 4 - (description_total_length % 4);
      for (let i = 0; i < padding; i++) {
        data.push(0);
      }
    }

    const object = {
      object_id: event_object_id,
      opcode: 5,
      data: new Uint8Array(data),
      file_descriptor,
    };
    if (wayland_debug_time_only()) {
      const d = object as any as Debug_Send_Message;
      d.object_name = "wl_output";
      d.message_name = "description";
      d.message_args = [
        { signature: "description: string", value: description },
      ];
    }
    s.send(object);
  };

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_output@${message.object_id}.release(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_output_release(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
          s.remove_global_bind(Global_Ids.wl_output, message.object_id as any);
        }

        break;
      }

      default:
        console.error("Unknown opcode on wl_output", message.opcode);
        break;
    }
  };
}
export enum wl_output_subpixel {
  unknown = 0,
  none = 1,
  horizontal_rgb = 2,
  horizontal_bgr = 3,
  vertical_rgb = 4,
  vertical_bgr = 5,
}
export enum wl_output_transform {
  normal = 0,
  _90 = 1,
  _180 = 2,
  _270 = 3,
  flipped = 4,
  flipped_90 = 5,
  flipped_180 = 6,
  flipped_270 = 7,
}
export enum wl_output_mode {
  current = 0x1,
  preferred = 0x2,
}

export interface wl_region_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_region_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_region>,
  ) => boolean;

  wl_region_add: (
    s: Wayland_Client,
    object_id: Object_ID<wl_region>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  wl_region_subtract: (
    s: Wayland_Client,
    object_id: Object_ID<wl_region>,
    x: Int32,
    y: Int32,
    width: Int32,
    height: Int32,
  ) => void;

  wl_region_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_region>,
    interface_: string,
    new_id: Object_ID<wl_region>,
    version_number: version,
  ) => void;
}

export class wl_region {
  constructor(public delegate: wl_region_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_region@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_region_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_region@${message.object_id}.add(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.wl_region_add(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      case 2: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const width =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const height =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_region@${message.object_id}.subtract(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ", ",
            "width: ",
            width,
            ", ",
            "height: ",
            height,
            ")",
          );
        }

        this.delegate.wl_region_subtract(
          s,
          message.object_id as any,
          x as any,
          y as any,
          width as any,
          height as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_region", message.opcode);
        break;
    }
  };
}

export interface wl_subcompositor_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_subcompositor_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subcompositor>,
  ) => boolean;

  wl_subcompositor_get_subsurface: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subcompositor>,
    id: Object_ID<wl_subsurface>,
    surface: Object_ID<wl_surface>,
    parent: Object_ID<wl_surface>,
  ) => void;

  wl_subcompositor_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_subcompositor>,
    interface_: string,
    new_id: Object_ID<wl_subcompositor>,
    version_number: version,
  ) => void;
}

export class wl_subcompositor {
  constructor(public delegate: wl_subcompositor_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subcompositor@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_subcompositor_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const id =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const surface =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const parent =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subcompositor@${message.object_id}.get_subsurface(`,
            "id: ",
            id,
            ", ",
            "surface: ",
            surface,
            ", ",
            "parent: ",
            parent,
            ")",
          );
        }

        this.delegate.wl_subcompositor_get_subsurface(
          s,
          message.object_id as any,
          id as any,
          surface as any,
          parent as any,
        );

        break;
      }

      default:
        console.error("Unknown opcode on wl_subcompositor", message.opcode);
        break;
    }
  };
}
export enum wl_subcompositor_error {
  bad_surface = 0,
  bad_parent = 1,
}

export interface wl_subsurface_delegate {
  /** @returns true if we should auto remove the object after destruction */
  wl_subsurface_destroy: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
  ) => boolean;

  wl_subsurface_set_position: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
    x: Int32,
    y: Int32,
  ) => void;

  wl_subsurface_place_above: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
    sibling: Object_ID<wl_surface>,
  ) => void;

  wl_subsurface_place_below: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
    sibling: Object_ID<wl_surface>,
  ) => void;

  wl_subsurface_set_sync: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
  ) => void;

  wl_subsurface_set_desync: (
    s: Wayland_Client,
    object_id: Object_ID<wl_subsurface>,
  ) => void;

  wl_subsurface_on_bind: (
    s: Wayland_Client,
    name: Object_ID<wl_subsurface>,
    interface_: string,
    new_id: Object_ID<wl_subsurface>,
    version_number: version,
  ) => void;
}

export class wl_subsurface {
  constructor(public delegate: wl_subsurface_delegate) {}

  on_request = (
    //@ts-ignore
    s: FileDescriptorClaim & Wayland_Client,
    message: DecodeState_Data,
  ) => {
    //@ts-ignore
    let _data_in_offset__ = 0;
    switch (message.opcode) {
      case 0: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.destroy(`,
            ")",
          );
        }

        const auto_remove = this.delegate.wl_subsurface_destroy(
          s,
          message.object_id as any,
        );

        if (auto_remove) {
          s.remove_object(message.object_id as any);
        }

        break;
      }

      case 1: {
        const x =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        const y =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.set_position(`,
            "x: ",
            x,
            ", ",
            "y: ",
            y,
            ")",
          );
        }

        this.delegate.wl_subsurface_set_position(
          s,
          message.object_id as any,
          x as any,
          y as any,
        );

        break;
      }

      case 2: {
        const sibling =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.place_above(`,
            "sibling: ",
            sibling,
            ")",
          );
        }

        this.delegate.wl_subsurface_place_above(
          s,
          message.object_id as any,
          sibling as any,
        );

        break;
      }

      case 3: {
        const sibling =
          message.data[_data_in_offset__ + 0]! |
          (message.data[_data_in_offset__ + 1]! << 8) |
          (message.data[_data_in_offset__ + 2]! << 16) |
          (message.data[_data_in_offset__ + 3]! << 24);

        _data_in_offset__ += 4;

        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.place_below(`,
            "sibling: ",
            sibling,
            ")",
          );
        }

        this.delegate.wl_subsurface_place_below(
          s,
          message.object_id as any,
          sibling as any,
        );

        break;
      }

      case 4: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.set_sync(`,
            ")",
          );
        }

        this.delegate.wl_subsurface_set_sync(s, message.object_id as any);

        break;
      }

      case 5: {
        if (wayland_debug_time_only()) {
          console.log(
            `[${debug_statement++}]: client#${s.client_socket} wl_subsurface@${message.object_id}.set_desync(`,
            ")",
          );
        }

        this.delegate.wl_subsurface_set_desync(s, message.object_id as any);

        break;
      }

      default:
        console.error("Unknown opcode on wl_subsurface", message.opcode);
        break;
    }
  };
}
export enum wl_subsurface_error {
  bad_surface = 0,
}
